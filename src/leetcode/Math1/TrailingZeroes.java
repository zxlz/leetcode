package leetcode.Math1;

import org.junit.Test;

/**
 * 阶乘后的零
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
 * @author zxl
 *
 *2 3 4 5 6 7 8 9 10 11 12 13
 *2 5 3 4 6 7 8 9 10 11 12 13
 *2（2 5） 3 4 6 7 8 9 11 12 13 14 20 25 30 35 40 45  50
 * 5 10 15 20 25 30 35；
 * 1 1   1  1  2
 * 1 2   3  4  5  6  7
 *000
 * 5 的个数。有5必有2
 */
public class TrailingZeroes {
	@Test
	public void main() {
		trailingZeroes(1808548329);
	}
	/**
	 * 对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。

n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n

因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。

但还没有结束，继续分析。

... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n

每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。

也就是我们需要再加上 n / 25 个 5。

同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。

综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。

最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...
	 * @param n
	 * @return
	 */
	  public int trailingZeroes(int n) {
		  int ans=0;
		  while(n>4) {
			  ans+= n /=5;
		  }
		  return ans;
	  }
    public int trailingZeroes1(int n) {
    	int ans=0;
    	while(n>4) {
    		if(n%5==0) {
    			ans++;
    			int t=n/5;
    			while(t%5==0) {
    				t /=5;
    				ans++;
    			}
                n -= 5;
    		}else{
                n--;
            }
    	}
		return ans;
    }
}
